---
title: 操作系统学习笔记
date: 2025-03-12 08:49:53
mathjax: true
categories: 
    - CS基础
cover: https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202509141037395.png
---


### CPU
#### CPU Cache
- 每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的
    ![](https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202509141048491.png)
- CPU Cache以Cache Line为操作的基本单位
![](https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202509141518827.png)



#### 缓存写策略
- 写直达（Write Through）：
    - 数据不在缓存时，直接写入内存
    - 数据在缓存，则写入缓存，并写入内存
- 写回（Write Back）
    - 写入数据如果在缓存，则只写入缓存，并标记所属cache block为脏数据块
        - 当脏数据块需要被其他数据写入时，把脏数据块写回内存同步
    - 数据不在缓存，则先从内存读取该数据所属数据块到缓存（保证后续对该数据块的访问都缓存命中），再写入缓存

#### 多核cpu的缓存一致性
> 实现了缓存一致性才能保证cpu的原子性操作在多核下保持正确性（cpu的数据读写，cas操作等）

##### 总线 ：将计算机的硬件设备联系起来（CPU,存储设备，IO设备等）
- cpu核心，DMA（direct memory access）等会通过总线与其他cpu核心，内存等传输数据
- 总线处理请求是串行化的，其硬件设备上有一套总线仲裁机制（比如先到先处理）来保证只有一个设备持有总线使用权

##### MESI协议
1. 总线嗅探（Bus Snooping） ：cpu会监控总线的活动，如果总线有在广播和自身持有缓存数据相关的信息，需要做出响应
1. MESI状态机
    - 四种状态
        - Modified，已修改 ：该缓存数据只有该核心持有，且修改过未同步到内存
        - Exclusive，独占 ：该缓存数据只有该核心持有，与内存数据一致
        - Shared，共享 ：缓存数据被多个核心持有
        - Invalidated，已失效 ：缓存数据废弃
    - 状态转移策略（每次都需请求总线使用权）
        - 读
            - 如果总线广播确认没有其它核心持有该缓存，则从内存读取并转为状态E
            - 如果有核心持有该缓存且状态M，则会把脏数据刷回内存，同时当前核心从内存读取数据，2个核心该缓存的状态都转为S
            - 如果有核心持有该缓存且状态为E或S，当前核心从内存读取，相关核心的缓存状态转为S
        - 写
            - 如果当前缓存状态是M或E，直接修改该缓存，状态设置为M
            - 如果为S，先通过总线将其他核心的缓存状态设为I，再修改缓存并设状态为M
            - 如果是I，则先执行读，再执行上述操作

### 进程管理
#### 进程和线程
> 进程是资源分配的最小单位，线程是CPU调度的最小单位

1. 进程间的通信方式
    + 管道/匿名管道(Pipes) ：半双工，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信（消息在内核缓冲区）
    + 有名管道(Named Pipes) : 严格遵循先进先出。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
    + 共享内存：需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。

1. 进程的调度算法
    + 先到先服务调度算法(FCFS，First Come, First Served) 
    + 短作业优先的调度算法(SJF，Shortest Job First)
    + 时间片轮转调度算法（RR，Round-Robin）
    + 优先级调度算法（Priority）
    + 多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）

1. 僵尸进程和孤儿进程
    + 子进程exit结束时，内核会释放该进程的所有资源，但其PCB依然存在于系统中。直到其父进程调用wait()才会被释放，以便让父进程得到子进程的状态信息。
    + 僵尸进程：子进程终止，但父进程没有调用 wait()导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。该子进程被称为“僵尸进程”。
    + 孤儿进程：父进程终止，但子进程仍在运行，未被wait()回收。该子进程为“孤儿进程”。OS会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。


1. 用户线程和守护线程
    1. 用户线程：只有所有用户线程结束，JVM才能终止（主线程main结束）
    1. 守护线程：不会阻止JVM结束
        + JVM结束时守护线程会被强制终止，不推荐执行I/O任务,会导致无法正确关闭资源
        + 守护线程一般用于后台支持任务，比如垃圾回收、释放未使用对象的内存等


#### 死锁
1. 死锁的四个必要条件
    1. 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。
    1. 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
    1. 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
    1. 循环等待：进程对资源的等待形成一个环

1. 死锁的预防
    1. 静态分配策略（破坏占有并等待）：进程只有执行前能申请所有资源才执行
    1. 层次分配策略（破坏循环等待）：资源分成多个层次，必须申请到低级资源才能申请高级资源，必须释放高级资源才能释放低级资源（单向性使得不存在循环等待，不会有高级资源申请低级资源的情况）

1. 死锁的避免
    + 将系统的状态分为 安全状态 和 不安全状态 ，在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。（银行家算法）

1. 死锁的检测：进程-资源分配图

1. 死锁的解除
    1. 抢占资源：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。
    1. 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。
    
### 内存管理
#### 基础
1. 字节序（大端存储 && 小端存储 ：多字节数据的存放方式）
    - 大端存储 ：高位字节存储在低地址处，低位字节存储在高地址处
    - 小端存储 ：低位字节存储在低地址处，高位字节存储在高地址处

#### 段页机制
1. 分段机制：每个申请内存的程序分配一个适合它大小的连续物理段，程序的虚拟地址通过段表映射到其分配的段上
    + 缺点：容易产生外部内存碎片（明明内存够分配给进程，但是不存在足够大小的**连续内存段**）
1. 分页机制：把物理内存分为连续等长的物理页（一般是4KB），虚拟内存也被划分成页。内存页是管理的基本单位
    + 多级页表的映射
        + 局部性原理：大多数进程不会使用到所有页，只使用少部分，一开始就给1024张页表太亏，采用2级页表：永存第一级页表，需要才增加第二级页表
        + 虚拟内存的地址的含义 ：[一级页表偏移量（10位），二级页表偏移量(10位)，页内地址偏移量（12位）]
    + 快表（TLB，Translation Lookaside Buffer）：即缓存，避免使用多级页表查询
    + 缺页中断（需要切换内核态，因为每个进程都可以保存一定数量的内存页而不是所有）
        + 硬性页缺失（Hard Page Fault）：如果访问页面不在内存，需要产生缺页中断，将该虚拟内存页映射的物理内存页(被置换到磁盘上了)拿到内存
        + 软性页缺失（Soft Page Fault）：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。    
    + 页面置换算法（减少缺页中断的产生）
        + 最佳页面置换算法（OPT，Optimal）
        + 先进先出页面置换算法（FIFO，First In First Out）：存在BeLady现象：分配的页面数增多但缺页率反而提高
        + 最近最久未使用页面置换算法（LRU ，Least Recently Used）：记录页面上次访问时间
        + 最少使用页面置换算法（LFU，Least Frequently Used） : 记录页面使用次数
1. 段页机制：把物理内存先分成若干段，每个段又继续分成若干大小相等的页。

#### 虚拟内存空间
- 虚拟内存空间大小为2^32 或2^64 ,其中内核空间和用户空间使用的虚拟地址范围不同
    ![](https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202509151911104.png)
- 每个进程使用独立的用户空间，但是他们指向的内核空间是同一个

- 用户进程空间又被划分为如下结构
    - 代码段(.text) ：只读，存放可执行二进制代码文件，字符串字面值和只读变量
    - 数据段(.data)/BSS段(.bss)(Block Started by Symbol)
        - 数据段存放已初始化的全局变量和静态变量
        - BSS段存放未初始化的全局变量和静态变量（设置为零值）
        - 在编译器和链接器生成可执行文件时，就已经计算好了上述变量所需空间
    - 堆(.heap) ：动态分配内存（向高地址增长）
    - 内存映射段（mmap，文件映射与匿名映射区） ：内核将硬盘文件直接映射到内存,或进行匿名内存映射用于存放程序数据
        - 避免了内核态与用户态间的数据拷贝（零拷贝）
        - 多进程间可共享映射的只读文件（动态共享库等）
    - 栈(.stack) ：存放函数的上下文，局部变量/对象，函数参数等（向低地址增长，有指定最大上限，多则栈溢出）
    ![](https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202509151914414.png)


- malloc-free ：C提供的动态内存分配/释放方法
    - `malloc()` ：根据申请内存大小，有2种执行方式
        - `brk()` ：用户分配的内存小于指定值(128kb)时调用，从堆移动堆顶指针进行分配
                - malloc内部会维护一个内存池（预先从堆申请的一块大内存,空闲链表管理），后续分配与释放都在这块大内存分配，避免系统调用
                - 缺点就是容易产生内存碎片，因此管理的内存不会太大
        - `mmap()` ：用户分配的内存大于指定值时调用，从文件映射区分配一块内存用于匿名映射（系统调用）
    - `realloc()` ：用于尝试改变原本指针指向的内存大小 
        - 如果指针所指内存是否有足够的连续空间，则原地设置新的内存大小，并且返回原来的地址指针
        - 否则申请一片新内存，并把原本内存数据拷贝到新内存

#### 内存分配机制
1. 进程向os申请资源时，分配的是虚拟内存，因此申请大小只要不超过虚拟内存均可（即用户空间）
1. 在访问不存在的虚拟页数据时，会产生缺页中断去获取物理页来映射
    - 如果内存不够，并开启swap机制，则会把部分数据页swap到磁盘，以提供空余数据页
    - 如果磁盘也不够，最终则是OOM（out of memory）


### 文件系统
1. 硬链接和软链接：每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。
    1. 硬链接（Hard Link，ln命令）：不能跨文件系统，硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的
    1. 软链接（Symbolic Link，ln -s命令）：能跨文件系统，类似快捷方式，可指向空文件/目录

1. 磁盘调度算法
    1. 先来先服务算法（First-Come First-Served，FCFS）
    1. 最短寻道时间优先算法（Shortest Seek Time First，SSTF）：优先选择距离当前磁头位置最近的请求进行服务
    1. 扫描算法（SCAN）：扫描到边界才转向
    1. 边扫描边观察算法（LOOK）：改进SCAN，移动方向上无请求，立即改变磁头方向
    1. 循环扫描算法（Circular Scan，C-SCAN）：只按照一个方向扫描
    1. 均衡循环扫描算法（C-LOOK）：改进C-SCAN，移动方向上无请求，立即让磁头返回



