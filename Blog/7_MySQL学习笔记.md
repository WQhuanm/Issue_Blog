---
title: MySQL学习笔记
date: 2025-02-21 04:28:59
categories: 
    - MySQL
tags: 
    - MySQL
cover: https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202502211226091.png
---

### 日志系统
+ 默认引擎InnoDB有专属日志：redo log（重做日志），具备crash-safe 能力
+ server层也有自己的日志：binlog（归档日志）。
+ 当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log，并更新内存，这个时候更新就算完成了。之后空闲再更新数据到磁盘
+ 日志进行**两阶段提交**
（WAL，Write-Ahead Logging）：它的关键点就是先写日志，再写磁盘。
只有redolog执行完接着binlog完整写入，然后redolog再进行事务提交才算事务生效

### 事务隔离
#### 1. 事务支持是在引擎层面实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。
#### 2. ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）
#### 3. 多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题
#### 4. 事务隔离级别：
+ 读未提交（read uncommitted）是指，一个事务还没提交时，它做的变更就能被别的事务看到。
+ 读提交（read committed,RC）是指，一个事务提交之后，它做的变更才会被其他事务看到。
+ 可重复读（repeatable read,RR）是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的（开启事务时建了一致性视图（不是一般的view视图））。
+ 串行化（serializable ），顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
#### 5. innodb支持RC和RR隔离级别实现是用的一致性视图(consistent read view)
+ InnoDB每个事务都有一个事务ID,叫做transaction id(严格递增)。每行数据的每个版本都会记录生成他的事务id（记为 row trx_id）
+ 一致性视图就是从当前版本回退到创建视图时的版本，实现一致性读。只有在一致性视图创建前的已提交事务的数据是可见的
+ 而更新数据有些不同，更新都是先读后写的，而这个读，只能读当前最新版本的值，称为“当前读”（current read）。
事务内部产生新的数据版本是可见的，因此更新后的查询基于当前读更新后的新版本
+ 在RR隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图。
在RC隔离级别下，每一个语句执行前都会重新算出一个新的视图。保证内部执行语句前获取所有已执行事务的数据

### 索引
#### 1. 索引是在存储引擎层实现的，InnoDB 使用了 B+ 树索引模型：只有叶子结点存数据，叶子结点使用链指针连成链表。能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。（N叉树，减少树高）
![](https://gcore.jsdelivr.net/gh/WQhuanm/Img_repo_1@main/img/202502201132435.png)
#### 2. 索引类型分为主键索引和非主键索引。（叶子结点存一张页，一页含多行有序数据）
+ 主键索引的叶子节点存的是整行数据。主键索引也被称为聚簇索引（clustered index）。
主键查询只需搜索主键索引树
+ 非主键索引的叶子节点内容是主键的值。非主键索引也被称为二级索引（secondary index）。
二级索引会把不包含的（联合）主键字段加入索引末尾来排序。
普通索引查询则需要先搜索其索引树，得到主键值再搜索主键索引树，这个过程称为回表。
#### 3. 覆盖索引：普通索引查询的主键字段+索引字段已经覆盖查询需求，则无需回表
#### 4. 最左前缀原则
联合索引的排序是自左向右按字段排序。查询时无需满足索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。
这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
+ 通过调整字段顺序可以优化多个索引占用的空间和索引数量，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
+ 对于既有联合查询，又有各自字段的查询，需要维护(a,b),(b)2种索引以满足要求，此时a为大字段，b为小字段即可节省空间
#### 5. 索引下推优化（index condition pushdown）
可以在索引遍历过程中，对索引中包含的所有字段先做判断，直接过滤掉不满足查询条件的记录，减少回表次数。
#### 6. 索引选择异常和处理
数据发生大量变化时，导致优化器的统计信息可能不准确，从而选错索引。使用ANALYZE TABLE分析表，以保持统计信息的准确性，优化查询性能。
即使信息准确，优化器仍然可能判断出错，解决思路：
+ 使用force index强制使用目标索引，但是会导致后期维护不便
+ 通过sql语句引导
+ 增加更合适索引供其选择，或删除索引
### MySQL锁
#### 1. 根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。
+ 全局锁的典型使用场景是，做全库逻辑备份。
+ 表级别的锁有两种：一种是表锁（lock tables ），一种是元数据锁（meta data lock，MDL)。
    + 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。
    + MDL的作用是保证读写的正确性。当对一个表做增删改查操作（DML，Data Manipulation Language)的时候，加 MDL 读锁；当要对表做结构变更操作(DDL，Data Definition Language)的时候，加 MDL 写锁。
    MDL锁是系统默认会加的，在语句执行开始时申请，但直到事务提交才释放。
+ 行锁（两阶段锁）：行锁是在需要的时候才加上的，但要等到事务结束时才释放。这个就是两阶段锁协议。
两阶段锁的特性所以要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放，减少锁住的时间。
        
### 数据库缓冲池
#### 1. change buffer（插入缓冲）
+ 更新数据页时，若数据页在内存中就直接更新，否则在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。 
change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上。
+ 只有普通索引可以使用chang buffer，唯一索引的更新操作都要先判断这个操作是否违反唯一性约束，这必须要将数据页读入内存才能判断。
在数据保证了唯一性下或者无要求唯一性时，优先使用普通索引提升性能
在一些“归档库”的场景，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。
+  对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
若一个业务的更新模式是写入之后马上会做查询，change buffer 反而起到了副作用。


### 
